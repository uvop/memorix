var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/memorix/docs/get-started/introduction/",title:"Introduction",description:`What is Memorix #Memorix is an open source next-generation in-memory ORM.
It has the following parts:
Memorix CLI - A command line interface tool to generate code from your schema, regardless of language your code is written in. Memorix clients - Runtime dependencies to the projects you use Memorix in. Why Memorix #Memorix was heavily inspired by GraphQL and Prisma.
Both of them cover the persistent memory and messaging layers, and they do it great.`,content:`What is Memorix #Memorix is an open source next-generation in-memory ORM.
It has the following parts:
Memorix CLI - A command line interface tool to generate code from your schema, regardless of language your code is written in. Memorix clients - Runtime dependencies to the projects you use Memorix in. Why Memorix #Memorix was heavily inspired by GraphQL and Prisma.
Both of them cover the persistent memory and messaging layers, and they do it great.
Though, once your application needs in-memory service, such as Redis, Kafka, RabbitMQ and etc, we felt these pains of not having a good enough tool for the cache layer, so we decided to write/make our own!
`}),e.add({id:1,href:"/memorix/docs/get-started/",title:"Get started",description:"Get started.",content:""}),e.add({id:2,href:"/memorix/docs/get-started/installation/",title:"Installation",description:`CLI installation #Follow the instructions below to install memorix-cli on your machine depending on the platform you use
macOS, linux and WSL installation #Requirements #brew — Package manager for macOS and linux. To install on Linux or WSL, couple of commands are required after the install script. Steps #Run these in the terminal
brew tap uvop/memorix brew install memorix memorix --version Done!
if successful, you should see the version installed in your terminal`,content:`CLI installation #Follow the instructions below to install memorix-cli on your machine depending on the platform you use
macOS, linux and WSL installation #Requirements #brew — Package manager for macOS and linux. To install on Linux or WSL, couple of commands are required after the install script. Steps #Run these in the terminal
brew tap uvop/memorix brew install memorix memorix --version Done!
if successful, you should see the version installed in your terminal
Windows #Requirements #choco — Package manager for Windows. Steps #Run these in the cmd
choco install memorix memorix --version Done!
if successful, you should see the version installed in your terminal
Manual installation #Go to memorix releases on github. Download the executable for your platform and place somewhere in your system (for instance, ~/.memorix) Add the folder where the executable is to your PATH environment variable. Done! Client installation #To start using Memorix, first head into your project(s) and install the run-time dependency.
At the moment, only Redis is supported
Redis client #Javascript Python Rust Deno
deno add jsr:@memorix/client-redis Bun
bunx jsr add @memorix/client-redis npm
npx jsr add @memorix/client-redis pip install memorix-client-redis or
poetry add memorix-client-redis cargo add memorix-client-redis Now we\u0026rsquo;re ready to start using Memorix! Head on to Quick start →
`}),e.add({id:3,href:"/memorix/docs/get-started/quick-start/",title:"Quick start",description:`Now we have all the tools needed to create our schema and start using it!
Creating schema #First, lets create a basic schema.
Create a file with name schema.memorix in the root of your project (remove unwanted output languages)
Config { engine: Redis(\u0026quot;redis://localhost:6379/0\u0026quot;) export: { files: [ { language: typescript path: \u0026quot;memorix.generated.ts\u0026quot; } { language: python path: \u0026quot;memorix_generated.py\u0026quot; } { language: rust path: \u0026quot;memorix_generated.rs\u0026quot; } ] } } Cache { hello: { payload: string } rating: { payload: u32 } } PubSub { message: { payload: string } } Now we can generate code for the schema we created using the Memorix CLI (and on future schema changes), simply un this in your terminal`,content:`Now we have all the tools needed to create our schema and start using it!
Creating schema #First, lets create a basic schema.
Create a file with name schema.memorix in the root of your project (remove unwanted output languages)
Config { engine: Redis(\u0026quot;redis://localhost:6379/0\u0026quot;) export: { files: [ { language: typescript path: \u0026quot;memorix.generated.ts\u0026quot; } { language: python path: \u0026quot;memorix_generated.py\u0026quot; } { language: rust path: \u0026quot;memorix_generated.rs\u0026quot; } ] } } Cache { hello: { payload: string } rating: { payload: u32 } } PubSub { message: { payload: string } } Now we can generate code for the schema we created using the Memorix CLI (and on future schema changes), simply un this in your terminal
memorix codegen ./schema.memorix Now API files have been generated in your source code folder, you can start using the API.
To format the schema file and validate it, run memorix fmt ./schema.memorix Using the schema API (redis) #Here is a code example of how to use the schema we created
Note: you need a redis service running, this code example assumes you do Javascript Python Rust import { Memorix } from \u0026quot;src/memorix.generated\u0026quot;; const start = async () =\u0026gt; { const memorix = new Memorix(); await memorix.cache.hello.set(\u0026quot;world\u0026quot;); await memorix.cache.rating.set(10); const helloValue = await memorix.cache.hello.get(); console.log(helloValue); // Should print \u0026quot;world\u0026quot; }; start(); from src.memorix_generated import Memorix memorix = Memorix() memorix.cache.hello.set(\u0026quot;world\u0026quot;) memorix.cache.rating.set(10) hello_value = memorix.cache.hello.get() print(hello_value) # Should print \u0026quot;world\u0026quot; mod memorix_generated; use memorix_generated as mx; #[tokio::main] async fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error + Sync + Send\u0026gt;\u0026gt; { let memorix = mx::Memorix::new().await?; memorix.cache.hello.set(\u0026amp;\u0026quot;world\u0026quot;.to_string()).await?; memorix.cache.rating.set(\u0026amp;10).await?; let hello_value = memorix.cache.hello.get().await?; println!(\u0026quot;{:?}\u0026quot;, hello_value); // Should print \u0026quot;world\u0026quot; Ok(()) } You can explore the API we created using your IDE since it\u0026rsquo;s fully typed. To learn which other features Memorix has to offer, start by checking defining your data →
`}),e.add({id:4,href:"/memorix/docs/concepts/",title:"Concepts",description:"Concepts.",content:""}),e.add({id:5,href:"/memorix/docs/concepts/data/",title:"Defining your data",description:`In the Quick start guide we got to put a simple string value in and out of the in-memory cache, here we\u0026rsquo;ll learn how to define more complicated data structures.
All the data transported through Memorix is parsed to and from JSON format, so to support that we introduced several of ways to define your data (again, inspired by GraphQL).
Primitive #Here are the basic primities you can use in your schema`,content:`In the Quick start guide we got to put a simple string value in and out of the in-memory cache, here we\u0026rsquo;ll learn how to define more complicated data structures.
All the data transported through Memorix is parsed to and from JSON format, so to support that we introduced several of ways to define your data (again, inspired by GraphQL).
Primitive #Here are the basic primities you can use in your schema
name Javascript type Python Rust string string str String u32 number int u32 i32 number int i32 f32 number float f32 u64 number int u64 i64 number int i64 f64 number float f64 boolean boolean bool boolean Example
Cache { hello { payload: string } myAge { payload: float } } Type #You can either define your objects inline or outside of your usage, for example
Inline
Cache { favoritePerson { payload: { name: string height: int age: float } } } Using Type
Type { Person: { name: string height: int age: float } } Cache { favoritePerson: { payload: Person } secondFavoritePerson: { payload: Person } } Nullable #All fields are required by default, to make them nullable, Simply add ? after the type
Type { Person: { name: string height: int age: float hairColor: string? } } Cache { favoritePerson: { payload: Person } secondFavoritePerson: { payload: Person? } } Array #Simply add braces [] around your type
Cache { cultMembers: { payload: [Person] } } Enum #Can help make your schema much more readable!
Enum { Animal { dog cat other } } Cache { favoriteAnimal: { payload: Animal } } Union #Unions aren\u0026rsquo;t supported, but you can use what we learned so far to define an object with different properties
Enum { AnimalType { dog cat other } } Type { Animal: { type: AnimalType name: string dogData: AnimalDogData? catData: AnimalCatData? otherData: AnimalOtherData? } AnimalDogData: { isAGoodBoy: boolean } AnimalCatData: { likesCatnip: boolean } AnimalOtherData: { tasty: boolean } } Cache { favoriteAnimal: { payload: Animal } } `}),e.add({id:6,href:"/memorix/docs/concepts/features/",title:"Features",description:`We\u0026rsquo;ll show the different applications you can use Memorix for, and how to do so
Cache #Cache is the most basic use of an in-memory service, to use it simply add a line to your Cache scope in schema.memorix:
Cache { adminUser: { payload: { email: string password: string } } } And to use it in your project Javascript Python Rust await memorix.cache.adminUser.set({ email: \u0026quot;me@mail.com\u0026quot;, password: \u0026quot;Aa123456\u0026quot;, }); const adminUser = await memorix.`,content:`We\u0026rsquo;ll show the different applications you can use Memorix for, and how to do so
Cache #Cache is the most basic use of an in-memory service, to use it simply add a line to your Cache scope in schema.memorix:
Cache { adminUser: { payload: { email: string password: string } } } And to use it in your project Javascript Python Rust await memorix.cache.adminUser.set({ email: \u0026quot;me@mail.com\u0026quot;, password: \u0026quot;Aa123456\u0026quot;, }); const adminUser = await memorix.cache.adminUser.get(); from src.generated_schema import Memorix, CacheAdminUser ... memorix.cache.adminUser.set(CacheAdminUser(email=\u0026quot;me@mail.com\u0026quot;, password=\u0026quot;Aa123456\u0026quot;)) admin_user = memorix.cache.adminUser.get() memorix.cache.adminUser.set( memorix_generated::CacheAdminUser { email: \u0026quot;me@mail.com\u0026quot;.to_string(), password: \u0026quot;Aa123456\u0026quot;.to_string(), } ).await?; let admin_user = memorix.cache.adminUser.get().await?; Cache key #If we want to store and get multiple objects of the same kind that\u0026rsquo;s also possible!
Cache { user { key: number payload: { email: string password: string } } } And to use it in your project Javascript Python Rust await memorix.cache.user.set(1, { email: \u0026quot;me@mail.com\u0026quot;, password: \u0026quot;Aa123456\u0026quot;, }); await memorix.cache.user.set(2, { email: \u0026quot;you@mail.com\u0026quot;, password: \u0026quot;Aa123456\u0026quot;, }); const me = await memorix.cache.user.get(1); from src.generated_schema import Memorix, CacheUser ... memorix.cache.user.set( 1, CacheAdminUser(email=\u0026quot;me@mail.com\u0026quot;, password=\u0026quot;Aa123456\u0026quot;), ) memorix.cache.user.set( 2, CacheAdminUser(email=\u0026quot;you@mail.com\u0026quot;, password=\u0026quot;Aa123456\u0026quot;), ) me = memorix.cache.adminUser.get(1) memorix.cache.user.set( \u0026amp;1, memorix_generated::CacheAdminUser { email: \u0026quot;me@mail.com\u0026quot;.to_string(), password: \u0026quot;Aa123456\u0026quot;.to_string(), }, ).await?; memorix.cache.user.set( \u0026amp;2, memorix_generated::CacheAdminUser { email: \u0026quot;you@mail.com\u0026quot;.to_string(), password: \u0026quot;Aa123456\u0026quot;, }, ).await?; let me = memorix.cache.adminUser.get(\u0026amp;1).await?; Key can be any type you like, even a nested object
Cache options #You can define cache options in your schema to change it\u0026rsquo;s behaviour
Cache { hello { payload: string ttl_ms: \u0026quot;10000\u0026quot; } helloForever { payload: string ttl_ms: \u0026quot;0\u0026quot; } } Here to defined that each cache item will expire in 5 seconds, but specifically hello will expire in 10 seconds and helloForever won\u0026rsquo;t expire.
name Type Default Description ttl_ms string or env value \u0026quot;0\u0026quot; - No expiration The numerical value of how many milliseconds until the data is expired and can be deleted from the cache, 0 for no expiration extend_on_get string or env value \u0026quot;false\u0026quot; If is set to true, the item\u0026rsquo;s expiration will be reset each time get api is called PubSub #PubSub (short for publish and subscribe) is a feature used to broadcast messages from one publisher to many subscribers.
Unlike Cache, the message isn\u0026rsquo;t saved anywhere and is just passed along.
To use it simply add a line to your PubSub scope in schema.memorix:
PubSub { message: { payload: string } } And to use it in your project Javascript Python Rust await { stop } = memorix.pubsub.message.subscribe(({ payload }) =\u0026gt; { // Will be called twice with \u0026quot;hello\u0026quot; then \u0026quot;world\u0026quot; console.log(\u0026quot;Got payload: \u0026quot; + payload); }); await memorix.pubsub.message.publish(\u0026quot;hello\u0026quot;); await memorix.pubsub.message.publish(\u0026quot;world\u0026quot;); await stop(); await memorix.pubsub.message.publish(\u0026quot;Will be published but no one is listening\u0026quot;); You can also subscribe to an Async iterable if you don\u0026rsquo;t pass a callback
const subscription = await memorix.pubsub.message.subscribe(); for await (const payload of subscription.asyncIterator) { console.log(\u0026quot;Got payload: \u0026quot; + payload); } To use python pubsub, you need to subscribe on a Thread or a Process since it\u0026rsquo;s a blocking code, for example
import multiprocessing def listen_to_message() -\u0026gt; None: for payload in memorix.pubsub.message.subscribe(): # Will be called twice with \u0026quot;hello\u0026quot; then \u0026quot;world\u0026quot; print(\u0026quot;Got payload: \u0026quot;, payload) process = multiprocessing.Process(target=listen_to_message) memorix.pubsub.message.publish(payload=\u0026quot;hello\u0026quot;) memorix.pubsub.message.publish(payload=\u0026quot;world\u0026quot;) process1.kill() memorix.pubsub.message.publish(payload=\u0026quot;Will be published but no one is listening\u0026quot;) To use rust pubsub, you need to subscribe on a different async function, for example
extern crate tokio; extern crate futures_util; use futures_util::StreamExt; async fn listen_to_message( mut memorix: example_schema_generated::Memorix, ) -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error + Sync + Send\u0026gt;\u0026gt; { let subscription = memorix.pubsub.message.subscribe().await? loop { let payload = subscription .next() .await .expect(\u0026quot;Subscription shouldn't end\u0026quot;)?; println!(\u0026quot;Got payload: {}\u0026quot;, payload); } Ok(()) } #[tokio::main] async fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error + Sync + Send\u0026gt;\u0026gt; { let mut memorix = example_schema_generated::Memorix::new(\u0026quot;redis://localhost:6379/0\u0026quot;).await?; let futures_v: Vec\u0026lt; std::pin::Pin\u0026lt; Box\u0026lt;dyn std::future::Future\u0026lt;Output = Result\u0026lt;(), Box\u0026lt;dyn std::error::Error + Sync + Send\u0026gt;\u0026gt;\u0026gt;\u0026gt;, \u0026gt;, \u0026gt; = vec![ Box::pin(listen_to_message(memorix.clone())), Box::pin(async move { memorix.pubsub.message.publish(\u0026amp;\u0026quot;hello\u0026quot;.to_string()).await?; memorix.pubsub.message.publish(\u0026amp;\u0026quot;world\u0026quot;.to_string()).await?; Ok(()) }), ]; futures::future::select_all(futures_v).await.0?; // Run until one is complete memorix.pubsub.message.publish(\u0026amp;\u0026quot;Will be published but no one is listening\u0026quot;.to_string()).await?; Ok(()) } PubSub key #PubSub also supports key the same as Cache supports it, you can use it to publish a message to a specific subscriber or a group.
Task #Task is the last feature Memorix supports, it sends a message to a specific queue, and one of the listeners picks it up.
Unlike PubSub, even if no one is listening to a queue, it\u0026rsquo;s saved and will be passed to a single listener once it starts listening.
To use it simply add a line to your Task scope in schema.memorix:
Task { addMessage: { payload: string } } And to use it in your project Javascript Python Rust await memorix.task.addMessage.queue(\u0026quot;hello\u0026quot;); await memorix.task.addMessage.queue(\u0026quot;world\u0026quot;); await { stop } = memorix.task.addMessage.dequeue(async (payload) =\u0026gt; { // Will be called twice with \u0026quot;hello\u0026quot; then \u0026quot;world\u0026quot; console.log(\u0026quot;Got payload: \u0026quot; + payload); // To stop listening, just for example if (payload === \u0026quot;world\u0026quot;) { await stop(); } }); // Emptys queue await memorix.task.addMessage.empty(); You might want to consider also using a Thread or a Process just like we did with PubSub, this example won\u0026rsquo;t do that
memorix.task.addMessage.queue(payload=\u0026quot;hello\u0026quot;) memorix.task.addMessage.queue(payload=\u0026quot;world\u0026quot;) for res in memorix.task.addMessage.dequeque(): # Will be called twice with \u0026quot;hello\u0026quot; then \u0026quot;world\u0026quot; print(\u0026quot;Got payload: \u0026quot;, res.payload) # To stop listening, just for example if res.payload == \u0026quot;world\u0026quot; break # Emptys queue memorix.task.addMessage.empty() memorix .task .pass_ball .addMessage .enqueue(\u0026amp;\u0026quot;hello\u0026quot;.to_string()) .await?; memorix .task .pass_ball .addMessage .enqueue(\u0026amp;\u0026quot;world\u0026quot;.to_string()) .await?; let mut async_iterator = memorix .task .addMessage .dequeue() .await?; loop { let payload = async_iterator .next() .await .ok_or(\u0026quot;Async Iterator shouldn't end\u0026quot;)??; if payload == \u0026quot;world\u0026quot; { break; } } memorix.task.addMessage.empty().await?; Task key #Task also supports key the same as Cache and PubSub support it, you can use put messages in different queues.
Task options #You can define task options globally or per task item in your schema to change it\u0026rsquo;s behaviour
Task { addMessage { payload: string queue_type: env(QUEUE_TYPE) } } name Type Default Description queue_type string or env value \u0026quot;fifo\u0026quot; fifo (first in first out) or lifo (last in first out) Namespace and imports #Namespaces are useful when using multiple schemas in order to avoid name collisions, also great for microservices to define their own schema.
To use it simply surround your desired scopes with a namespace scope
messages-schema.memorix
Namespace messages { PubSub { addItem: { payload: int public: [publish subscribe] } } } then you can import it in your main schema
schema.memorix
Config { import: [ \u0026quot;\u0026lt;path-to\u0026gt;/messages-schema.memorix\u0026quot; \u0026quot;\u0026lt;path-to\u0026gt;/another-schema.memorix\u0026quot; ] export: { files: [ { language: typescript path: \u0026quot;memorix.generated.ts\u0026quot; } ] } } PubSub { addItem { payload: string } } Even though we defined PubSub.addItem twice, since one is in a namespace, they won\u0026rsquo;t collide with each other.
To use it in your project Javascript Python Rust await memorix.pubsub.addItem.publish(12); await memorix.messages.pubsub.addItem.publish(\u0026quot;in 'messages' namespace\u0026quot;); memorix.pubusb.addItem.publish(payload=12) memorix.messages.pubusb.addItem.publish(payload=\u0026quot;woin 'messages' namespacerld\u0026quot;) memorix.pubusb.addItem.publish(\u0026amp;12).await?; memorix.messages.pubusb.addItem.publish(\u0026amp;\u0026quot;woin 'messages' namespacerld\u0026quot;).await?; You can also see we defined public in the imported messages-schema.memorix, by default, all imported API is private. Here is a list of methods which we can define as public
Cache methods (can be defined as private / public)
name Description get Getting the stored value set Setting the stored value delete Deleting the stored value PubSub methods (can be defined as private / public)
name Description publish Publishing a value to all listeners subscribe Subscribing as a listener Task methods (can be defined as private / public)
name Description enqueue Adding a value to the queue dequeue Getting a value from the queue empty Clearing the queue get_len Get current length of the queue `}),e.add({id:7,href:"/memorix/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()