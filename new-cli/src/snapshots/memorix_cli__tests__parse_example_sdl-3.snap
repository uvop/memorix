---
source: src/main.rs
assertion_line: 420
expression: rust_code
---
#![allow(dead_code)]
extern crate memorix_client_redis;

#[derive(Clone, memorix_client_redis::Serialize, memorix_client_redis::Deserialize, PartialEq, std::fmt::Debug)]
pub struct InlineCachePayloadMessage {
    pub id: String,
    pub sender_id: UserId,
    pub recipient_id: UserId,
    pub content: String,
    pub timestamp: u64,
}


#[derive(Clone, memorix_client_redis::Serialize, memorix_client_redis::Deserialize, PartialEq, std::fmt::Debug)]
pub struct InlinePubSubPayloadNewMessage {
    pub message_id: String,
    pub recipient_id: UserId,
}


#[derive(Clone, memorix_client_redis::Serialize, memorix_client_redis::Deserialize, PartialEq, std::fmt::Debug)]
pub struct InlineTaskPayloadMessageProcessingTasks {
    pub message_id: String,
    pub processing_type: String,
    pub priority: u32,
}


#[derive(Clone, memorix_client_redis::Serialize, memorix_client_redis::Deserialize, PartialEq, std::fmt::Debug)]
pub struct InlineCachePayloadUserProfile {
    pub id: u32,
    pub name: String,
    pub email: String,
}


#[derive(Clone, memorix_client_redis::Serialize, memorix_client_redis::Deserialize, PartialEq, std::fmt::Debug)]
pub struct InlineCachePayloadUserSession {
    pub user_id: u32,
    pub session_token: String,
    pub expiry: u64,
}


pub type abc = u32;

#[allow(non_camel_case_types, clippy::upper_case_acronyms)]
#[derive(Clone, memorix_client_redis::Serialize, memorix_client_redis::Deserialize, PartialEq, std::fmt::Debug,
)]
pub enum Operation {
    START,
    STOP,
}

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCacheMessageService {
    pub message: memorix_client_redis::MemorixCacheItem<String, InlineCachePayloadMessage, memorix_client_redis::Expose, memorix_client_redis::Expose, memorix_client_redis::Expose>,
}

impl MemorixCacheMessageService {
    fn new(memorix_base: memorix_client_redis::MemorixBase) -> Self {
        Self {
            message: memorix_client_redis::MemorixCacheItem::new(
                memorix_base.clone(),
                "message".to_string(),
                None,
            ),
        }
    }
}

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixPubSubMessageService {
    pub new_message: memorix_client_redis::MemorixPubSubItem<UserId, InlinePubSubPayloadNewMessage, memorix_client_redis::Expose, memorix_client_redis::Expose>,
}

impl MemorixPubSubMessageService {
    fn new(memorix_base: memorix_client_redis::MemorixBase) -> Self {
        Self {
            new_message: memorix_client_redis::MemorixPubSubItem::new(
                memorix_base.clone(),
                "new_message".to_string(),
            ),
        }
    }
}

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixTaskMessageService {
    pub message_processing_tasks: memorix_client_redis::MemorixTaskItemNoKey<InlineTaskPayloadMessageProcessingTasks, memorix_client_redis::Expose, memorix_client_redis::Expose, memorix_client_redis::Expose, memorix_client_redis::Expose>,
}

impl MemorixTaskMessageService {
    fn new(memorix_base: memorix_client_redis::MemorixBase) -> Self {
        Self {
            message_processing_tasks: memorix_client_redis::MemorixTaskItemNoKey::new(
                memorix_base.clone(),
                "message_processing_tasks".to_string(),
                memorix_client_redis::MemorixTaskOptions {
                    queue_type: "Fifo",
                },
            ),
        }
    }
}

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixMessageService {
    pub cache: MemorixCacheMessageService,
    pub pubsub: MemorixPubSubMessageService,
    pub task: MemorixTaskMessageService,
}

const MEMORIX_MESSAGE_SERVICE_NAMESPACE_NAME_TREE: &[&str] = &["MessageService"];

impl MemorixMessageService {
    pub fn new(
        other: memorix_client_redis::MemorixBase,
    ) -> Result<MemorixMessageService, Box<dyn std::error::Error + Sync + Send>> {
        let memorix_base = memorix_client_redis::MemorixBase::from(
            other,
            MEMORIX_MESSAGE_SERVICE_NAMESPACE_NAME_TREE
        );
        Ok(Self {
            cache: MemorixCacheMessageService::new(memorix_base.clone()),
            pubsub: MemorixPubSubMessageService::new(memorix_base.clone()),
            task: MemorixTaskMessageService::new(memorix_base.clone()),
        })
    }
}

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCache {
    pub user_profile: memorix_client_redis::MemorixCacheItem<u32, InlineCachePayloadUserProfile, memorix_client_redis::Expose, memorix_client_redis::Expose, memorix_client_redis::Expose>,
    pub user_session: memorix_client_redis::MemorixCacheItem<String, InlineCachePayloadUserSession, memorix_client_redis::Expose, memorix_client_redis::Expose, memorix_client_redis::Expose>,
    pub number_of_messages: memorix_client_redis::MemorixCacheItemNoKey<u32, memorix_client_redis::Expose, memorix_client_redis::Hide, memorix_client_redis::Hide>,
}

impl MemorixCache {
    fn new(memorix_base: memorix_client_redis::MemorixBase) -> Self {
        Self {
            user_profile: memorix_client_redis::MemorixCacheItem::new(
                memorix_base.clone(),
                "user_profile".to_string(),
                None,
            ),
            user_session: memorix_client_redis::MemorixCacheItem::new(
                memorix_base.clone(),
                "user_session".to_string(),
                memorix_client_redis::MemorixCacheOptions {
                    ttl: std::env::var("USER_SESSION_TTL").expect("missing environment variable USER_SESSION_TTL"),
                },
            ),
            number_of_messages: memorix_client_redis::MemorixCacheItemNoKey::new(
                memorix_base.clone(),
                "number_of_messages".to_string(),
                None,
            ),
        }
    }
}

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix {
    pub MessageService: MemorixMessageService,

    pub cache: MemorixCache,
}

const MEMORIX_NAMESPACE_NAME_TREE: &[&str] = &[];

impl Memorix {
    pub async fn new() -> Result<Memorix, Box<dyn std::error::Error + Sync + Send>> {
        let memorix_base = memorix_client_redis::MemorixBase::new(
            std::env::var("REDIS_URL").expect("missing environment variable REDIS_URL"),
            MEMORIX_NAMESPACE_NAME_TREE
        )
        .await?;
        Ok(Self {
            MessageService: MemorixMessageService::new(memorix_base.clone())?,

            cache: MemorixCache::new(memorix_base.clone()),
        })
    }
}
