// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`python codegen cache can generate also with model 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct User {
    pub name: String,
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub age: Option<i32>,
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCache<'a> {
    pub adminId: memorix_redis::MemorixCacheItemNoKey<'a, Option<String>>,
    pub user: memorix_redis::MemorixCacheItem<'a, String, User>,
}

impl<'a> MemorixCache<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            adminId: memorix_redis::MemorixCacheItemNoKey::new(
                memorix_base.clone(),
                \\"adminId\\",
            ),
            user: memorix_redis::MemorixCacheItem::new(
                memorix_base.clone(),
                \\"user\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub cache: MemorixCache<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            cache: MemorixCache::new(memorix_base.clone()),
        })
    }
}"
`;

exports[`python codegen cache can generate with inline object type 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct CacheUserPayload {
    pub name: String,
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub age: Option<i32>,
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCache<'a> {
    pub user: memorix_redis::MemorixCacheItem<'a, i32, Option<CacheUserPayload>>,
}

impl<'a> MemorixCache<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            user: memorix_redis::MemorixCacheItem::new(
                memorix_base.clone(),
                \\"user\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub cache: MemorixCache<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            cache: MemorixCache::new(memorix_base.clone()),
        })
    }
}"
`;

exports[`python codegen cache can generate with inline types 1`] = `
"extern crate memorix_redis;

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCache<'a> {
    pub user: memorix_redis::MemorixCacheItem<'a, i32, String>,
}

impl<'a> MemorixCache<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            user: memorix_redis::MemorixCacheItem::new(
                memorix_base.clone(),
                \\"user\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub cache: MemorixCache<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            cache: MemorixCache::new(memorix_base.clone()),
        })
    }
}"
`;

exports[`python codegen cache can generate with inline types and convert to CamelCase 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct CacheUserByNumberPayload {
    pub name: String,
    pub age: i32,
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCache<'a> {
    pub user_by_number: memorix_redis::MemorixCacheItem<'a, i32, CacheUserByNumberPayload>,
}

impl<'a> MemorixCache<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            user_by_number: memorix_redis::MemorixCacheItem::new(
                memorix_base.clone(),
                \\"user_by_number\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub cache: MemorixCache<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            cache: MemorixCache::new(memorix_base.clone()),
        })
    }
}"
`;

exports[`python codegen cache can generate with no key 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct CacheUserPayload {
    pub name: String,
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub age: Option<i32>,
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCache<'a> {
    pub user: memorix_redis::MemorixCacheItemNoKey<'a, Option<CacheUserPayload>>,
}

impl<'a> MemorixCache<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            user: memorix_redis::MemorixCacheItemNoKey::new(
                memorix_base.clone(),
                \\"user\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub cache: MemorixCache<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            cache: MemorixCache::new(memorix_base.clone()),
        })
    }
}"
`;

exports[`python codegen cache can have options 1`] = `
"extern crate memorix_redis;

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCache<'a> {
    pub user: memorix_redis::MemorixCacheItem<'a, i32, String>,
}

impl<'a> MemorixCache<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            user: memorix_redis::MemorixCacheItem::new(
                memorix_base.clone(),
                \\"user\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub cache: MemorixCache<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            cache: MemorixCache::new(memorix_base.clone()),
        })
    }
}"
`;

exports[`python codegen config can be null 1`] = `
"extern crate memorix_redis;

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {


}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            Some(memorix_redis::MemorixOptions {
                cache: Some(memorix_redis::MemorixOptionsCache {
                    expire: None,
                }),
                task: None,
            })
        ).await?;
        Ok(Self {


        })
    }
}"
`;

exports[`python codegen config can generate 1`] = `
"extern crate memorix_redis;

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {


}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            Some(memorix_redis::MemorixOptions {
                cache: Some(memorix_redis::MemorixOptionsCache {
                    expire: Some(memorix_redis::MemorixOptionsCacheExpire {
                        value: 5,
                        is_in_ms: None,
                        extend_on_get: Some(true),
                    }),
                }),
                task: MemorixTaskItem.Options(
                    take_newest=True,
                ),
            })
        ).await?;
        Ok(Self {


        })
    }
}"
`;

exports[`python codegen enum can generate 1`] = `
"extern crate memorix_redis;

#[allow(non_camel_case_types, clippy::upper_case_acronyms)]
#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize, PartialEq, std::fmt::Debug)]
pub enum Animals {
    dog,
    cat,
    person,
}"
`;

exports[`python codegen model can generate from 2 models 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct User1 {
    pub id: i32,
}


#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct User2 {
    pub name: String,
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub age: Option<i32>,
}"
`;

exports[`python codegen model can generate from model 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct User {
    pub id: i32,
    pub name: String,
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub age: Option<f32>,
}"
`;

exports[`python codegen model can generate from model with array 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct UserChildren {
    pub id: i32,
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub name: Option<String>,
}


#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct User {
    pub id: i32,
    pub names: Vec<String>,
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub children: Option<Vec<Option<UserChildren>>>,
}"
`;

exports[`python codegen model can generate from model within model 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct UserPapa {
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub name: Option<String>,
}


#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct User {
    pub id: i32,
    pub papa: UserPapa,
}"
`;

exports[`python codegen model can generate from model within model within a model 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct UserPapaMama {
    pub sick: bool,
}


#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct UserPapa {
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = \\"Option::is_none\\")]
    pub mama: Option<UserPapaMama>,
    pub age: i32,
}


#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct User {
    pub id: i32,
    pub papa: UserPapa,
}"
`;

exports[`python codegen namespace can generate 1`] = `
"extern crate memorix_redis;

#[derive(Clone, memorix_redis::Serialize, memorix_redis::Deserialize)]
pub struct UserCacheBioPayload {
    pub description: String,
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCacheUser<'a> {
    pub bio: memorix_redis::MemorixCacheItemNoKey<'a, UserCacheBioPayload>,
}

impl<'a> MemorixCacheUser<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            bio: memorix_redis::MemorixCacheItemNoKey::new(
                memorix_base.clone(),
                \\"bio\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixUser<'a> {

    pub cache: MemorixCacheUser<'a>,
}

const MEMORIX_USER_NAMESPACE_NAME_TREE: &'static [&'static str] = &[\\"user\\"];

impl<'a> MemorixUser<'a> {
    pub fn new(other: memorix_redis::MemorixBase) -> Result<MemorixUser<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::from(
            other,
            MEMORIX_USER_NAMESPACE_NAME_TREE,
            Some(memorix_redis::MemorixOptions {
                cache: Some(memorix_redis::MemorixOptionsCache {
                    expire: Some(memorix_redis::MemorixOptionsCacheExpire {
                        value: 5,
                        is_in_ms: None,
                        extend_on_get: None,
                    }),
                }),
                task: None,
            })
        );
        Ok(Self {

            cache: MemorixCacheUser::new(memorix_base.clone()),
        })
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixCacheSpaceship<'a> {
    pub bio: memorix_redis::MemorixCacheItemNoKey<'a, String>,
}

impl<'a> MemorixCacheSpaceship<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            bio: memorix_redis::MemorixCacheItemNoKey::new(
                memorix_base.clone(),
                \\"bio\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixSpaceship<'a> {

    pub cache: MemorixCacheSpaceship<'a>,
}

const MEMORIX_SPACESHIP_NAMESPACE_NAME_TREE: &'static [&'static str] = &[\\"spaceship\\"];

impl<'a> MemorixSpaceship<'a> {
    pub fn new(other: memorix_redis::MemorixBase) -> Result<MemorixSpaceship<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::from(
            other,
            MEMORIX_SPACESHIP_NAMESPACE_NAME_TREE,
            Some(memorix_redis::MemorixOptions {
                cache: Some(memorix_redis::MemorixOptionsCache {
                    expire: Some(memorix_redis::MemorixOptionsCacheExpire {
                        value: 5,
                        is_in_ms: None,
                        extend_on_get: None,
                    }),
                }),
                task: None,
            })
        );
        Ok(Self {

            cache: MemorixCacheSpaceship::new(memorix_base.clone()),
        })
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {
            pub user: MemorixUser<'a>,
            pub spaceship: MemorixSpaceship<'a>,


}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {
            user: MemorixUser::new(memorix_base.clone())?,
            spaceship: MemorixSpaceship::new(memorix_base.clone())?,


        })
    }
}"
`;

exports[`python codegen pubsub can generate with inline types 1`] = `
"extern crate memorix_redis;

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixPubSub<'a> {
    pub message: memorix_redis::MemorixPubSubItem<'a, i32, String>,
}

impl<'a> MemorixPubSub<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            message: memorix_redis::MemorixPubSubItem::new(
                memorix_base.clone(),
                \\"message\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub pubsub: MemorixPubSub<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            pubsub: MemorixPubSub::new(memorix_base.clone()),
        })
    }
}"
`;

exports[`python codegen task can generate with inline types 1`] = `
"extern crate memorix_redis;

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixTask<'a> {
    pub doIt: memorix_redis::MemorixTaskItem<'a, i32, String, bool>,
}

impl<'a> MemorixTask<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            doIt: memorix_redis::MemorixTaskItem::new(
                memorix_base.clone(),
                \\"doIt\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub task: MemorixTask<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            task: MemorixTask::new(memorix_base.clone()),
        })
    }
}"
`;

exports[`python codegen task can have options 1`] = `
"extern crate memorix_redis;

#[derive(Clone)]
#[allow(non_snake_case)]
pub struct MemorixTask<'a> {
    pub doIt: memorix_redis::MemorixTaskItem<'a, i32, String, bool>,
}

impl<'a> MemorixTask<'a> {
    fn new(memorix_base: memorix_redis::MemorixBase) -> Self {
        Self {
            doIt: memorix_redis::MemorixTaskItem::new(
                memorix_base.clone(),
                \\"doIt\\",
            ),
        }
    }
}


#[derive(Clone)]
#[allow(non_snake_case)]
pub struct Memorix<'a> {

    pub task: MemorixTask<'a>,
}

const MEMORIX_NAMESPACE_NAME_TREE: &'static [&'static str] = &[];

impl<'a> Memorix<'a> {
    pub async fn new(redis_url: &str) -> Result<Memorix<'a>, Box<dyn std::error::Error>> {
        let memorix_base = memorix_redis::MemorixBase::new(
            redis_url,
            MEMORIX_NAMESPACE_NAME_TREE,
            None
        ).await?;
        Ok(Self {

            task: MemorixTask::new(memorix_base.clone()),
        })
    }
}"
`;
